{
    "sourceFile": "backend/controllers/authController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1752729064162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752746077990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,448 +1,63 @@\n import User from '../models/User.js';\r\n-import { generateToken, generateRefreshToken } from '../middleware/auth.js';\r\n-import { logger } from '../config/logger.js';\r\n-import crypto from 'crypto';\r\n-import axios from 'axios';\r\n+import jwt from 'jsonwebtoken';\r\n \r\n-// @desc    Register user\r\n-// @route   POST /api/v1/auth/register\r\n-// @access  Public\r\n+// Helper to generate JWT\r\n+const generateToken = (id) =>\r\n+  jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN || '7d' });\r\n+\r\n+// Register\r\n export const register = async (req, res) => {\r\n   try {\r\n-    const {\r\n-      username,\r\n-      email,\r\n-      password,\r\n-      firstName,\r\n-      lastName,\r\n-      dateOfBirth,\r\n-      referredBy,\r\n-    } = req.body;\r\n-\r\n-    // Check if user already exists\r\n-    const existingUser = await User.findByEmailOrUsername(email);\r\n-    if (existingUser) {\r\n-      return res.status(400).json({\r\n-        success: false,\r\n-        error: 'User already exists with this email or username',\r\n-      });\r\n+    const { username, email, password, firstName, lastName, dateOfBirth } = req.body;\r\n+    if (!username || !email || !password || !firstName || !lastName || !dateOfBirth) {\r\n+      return res.status(400).json({ success: false, error: 'All fields are required.' });\r\n     }\r\n-\r\n-    // Check if username is taken\r\n-    const usernameExists = await User.findOne({ username });\r\n-    if (usernameExists) {\r\n-      return res.status(400).json({\r\n-        success: false,\r\n-        error: 'Username is already taken',\r\n-      });\r\n+    const exists = await User.findOne({ $or: [{ username }, { email }] });\r\n+    if (exists) {\r\n+      return res.status(400).json({ success: false, error: 'Username or email already exists.' });\r\n     }\r\n-\r\n-    // Handle referral\r\n-    let referredByUser = null;\r\n-    if (referredBy) {\r\n-      referredByUser = await User.findByReferralCode(referredBy);\r\n-      if (!referredByUser) {\r\n-        return res.status(400).json({\r\n-          success: false,\r\n-          error: 'Invalid referral code',\r\n-        });\r\n-      }\r\n-    }\r\n-\r\n-    // Create user\r\n-    const user = new User({\r\n-      username,\r\n-      email,\r\n-      password,\r\n-      firstName,\r\n-      lastName,\r\n-      dateOfBirth: new Date(dateOfBirth),\r\n-      referredBy: referredByUser?._id,\r\n-      loginMethod: 'local',\r\n-    });\r\n-\r\n+    const user = new User({ username, email, password, firstName, lastName, dateOfBirth, loginMethod: 'local' });\r\n     await user.save();\r\n-\r\n-    // Update referrer's referral count\r\n-    if (referredByUser) {\r\n-      referredByUser.referralCount += 1;\r\n-      await referredByUser.save();\r\n-    }\r\n-\r\n-    // Generate tokens\r\n-    const token = generateToken(user._id);\r\n-    const refreshToken = generateRefreshToken(user._id);\r\n-\r\n-    // Update last login\r\n-    user.lastLogin = new Date();\r\n-    await user.save();\r\n-\r\n-    res.status(201).json({\r\n-      success: true,\r\n-      data: {\r\n-        user: {\r\n-          id: user._id,\r\n-          username: user.username,\r\n-          email: user.email,\r\n-          firstName: user.firstName,\r\n-          lastName: user.lastName,\r\n-          isEmailVerified: user.isEmailVerified,\r\n-          balance: user.balance,\r\n-          level: user.level,\r\n-          experience: user.experience,\r\n-          referralCode: user.referralCode,\r\n-        },\r\n-        accessToken: token,\r\n-        refreshToken: refreshToken,\r\n-      },\r\n-      message: 'Registration successful',\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Registration error:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: 'Registration failed',\r\n-    });\r\n+    res.status(201).json({ success: true, message: 'Registration successful.' });\r\n+  } catch (err) {\r\n+    res.status(500).json({ success: false, error: err.message });\r\n   }\r\n };\r\n \r\n-// @desc    Login user\r\n-// @route   POST /api/v1/auth/login\r\n-// @access  Public\r\n+// Login\r\n export const login = async (req, res) => {\r\n   try {\r\n-    const { username, password, captchaToken } = req.body;\r\n-\r\n-    // Verify reCAPTCHA\r\n-    if (process.env.NODE_ENV === 'production') {\r\n-      const recaptchaResponse = await axios.post(\r\n-        'https://www.google.com/recaptcha/api/siteverify',\r\n-        null,\r\n-        {\r\n-          params: {\r\n-            secret: process.env.RECAPTCHA_SECRET_KEY,\r\n-            response: captchaToken,\r\n-          },\r\n-        }\r\n-      );\r\n-\r\n-      if (!recaptchaResponse.data.success) {\r\n-        return res.status(400).json({\r\n-          success: false,\r\n-          error: 'reCAPTCHA verification failed',\r\n-        });\r\n-      }\r\n+    const { username, password } = req.body;\r\n+    if (!username || !password) {\r\n+      return res.status(400).json({ success: false, error: 'Username and password required.' });\r\n     }\r\n-\r\n-    // Find user by username or email\r\n-    const user = await User.findByEmailOrUsername(username);\r\n-    if (!user) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        error: 'Invalid credentials',\r\n-      });\r\n+    const user = await User.findOne({ $or: [{ username }, { email: username }] });\r\n+    if (!user || user.loginMethod !== 'local') {\r\n+      return res.status(401).json({ success: false, error: 'Invalid credentials.' });\r\n     }\r\n-\r\n-    // Check if account is locked\r\n-    if (user.isLocked()) {\r\n-      return res.status(423).json({\r\n-        success: false,\r\n-        error: 'Account is temporarily locked due to too many failed attempts',\r\n-      });\r\n+    const isMatch = await user.comparePassword(password);\r\n+    if (!isMatch) {\r\n+      return res.status(401).json({ success: false, error: 'Invalid credentials.' });\r\n     }\r\n-\r\n-    // Check if account is banned\r\n-    if (user.isBanned) {\r\n-      return res.status(403).json({\r\n-        success: false,\r\n-        error: `Account is banned: ${user.banReason}`,\r\n-      });\r\n-    }\r\n-\r\n-    // Check if account is active\r\n-    if (!user.isActive) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        error: 'Account is deactivated',\r\n-      });\r\n-    }\r\n-\r\n-    // Verify password\r\n-    const isPasswordValid = await user.comparePassword(password);\r\n-    if (!isPasswordValid) {\r\n-      // Increment login attempts\r\n-      await user.incLoginAttempts();\r\n-      \r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        error: 'Invalid credentials',\r\n-      });\r\n-    }\r\n-\r\n-    // Reset login attempts on successful login\r\n-    if (user.loginAttempts > 0) {\r\n-      user.loginAttempts = 0;\r\n-      user.lockUntil = undefined;\r\n-    }\r\n-\r\n-    // Update last login\r\n-    user.lastLogin = new Date();\r\n-    await user.save();\r\n-\r\n-    // Generate tokens\r\n     const token = generateToken(user._id);\r\n-    const refreshToken = generateRefreshToken(user._id);\r\n-\r\n-    res.json({\r\n-      success: true,\r\n-      data: {\r\n-        user: {\r\n-          id: user._id,\r\n-          username: user.username,\r\n-          email: user.email,\r\n-          firstName: user.firstName,\r\n-          lastName: user.lastName,\r\n-          isEmailVerified: user.isEmailVerified,\r\n-          balance: user.balance,\r\n-          level: user.level,\r\n-          experience: user.experience,\r\n-          referralCode: user.referralCode,\r\n-          avatar: user.avatar,\r\n-        },\r\n-        accessToken: token,\r\n-        refreshToken: refreshToken,\r\n-      },\r\n-      message: 'Login successful',\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Login error:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: 'Login failed',\r\n-    });\r\n+    res.json({ success: true, data: { user, accessToken: token } });\r\n+  } catch (err) {\r\n+    res.status(500).json({ success: false, error: err.message });\r\n   }\r\n };\r\n \r\n-// @desc    Google OAuth login\r\n-// @route   GET /api/v1/auth/google\r\n-// @access  Public\r\n-export const googleAuth = (req, res, next) => {\r\n-  // This will be handled by passport middleware\r\n-  next();\r\n-};\r\n-\r\n-// @desc    Google OAuth callback\r\n-// @route   GET /api/v1/auth/google/callback\r\n-// @access  Public\r\n+// Google OAuth\r\n+export const googleAuth = (req, res, next) => next();\r\n export const googleCallback = (req, res) => {\r\n-  try {\r\n-    const { user } = req;\r\n-    \r\n-    if (!user) {\r\n-      return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n-    }\r\n-\r\n-    // Generate tokens\r\n-    const token = generateToken(user._id);\r\n-    const refreshToken = generateRefreshToken(user._id);\r\n-\r\n-    // Update last login\r\n-    user.lastLogin = new Date();\r\n-    user.save();\r\n-\r\n-    // Redirect to frontend with tokens\r\n-    const redirectUrl = `${process.env.FRONTEND_URL}/oauth-callback?token=${token}&refreshToken=${refreshToken}&user=${encodeURIComponent(JSON.stringify(user))}`;\r\n-    res.redirect(redirectUrl);\r\n-  } catch (error) {\r\n-    logger.error('Google OAuth callback error:', error);\r\n-    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n-  }\r\n+  if (!req.user) return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n+  const token = generateToken(req.user._id);\r\n+  res.redirect(`${process.env.FRONTEND_URL}/oauth-callback?token=${token}`);\r\n };\r\n \r\n-// @desc    Facebook OAuth login\r\n-// @route   GET /api/v1/auth/facebook\r\n-// @access  Public\r\n-export const facebookAuth = (req, res, next) => {\r\n-  // This will be handled by passport middleware\r\n-  next();\r\n-};\r\n-\r\n-// @desc    Facebook OAuth callback\r\n-// @route   GET /api/v1/auth/facebook/callback\r\n-// @access  Public\r\n+// Facebook OAuth\r\n+export const facebookAuth = (req, res, next) => next();\r\n export const facebookCallback = (req, res) => {\r\n-  try {\r\n-    const { user } = req;\r\n-    \r\n-    if (!user) {\r\n-      return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n-    }\r\n-\r\n-    // Generate tokens\r\n-    const token = generateToken(user._id);\r\n-    const refreshToken = generateRefreshToken(user._id);\r\n-\r\n-    // Update last login\r\n-    user.lastLogin = new Date();\r\n-    user.save();\r\n-\r\n-    // Redirect to frontend with tokens\r\n-    const redirectUrl = `${process.env.FRONTEND_URL}/oauth-callback?token=${token}&refreshToken=${refreshToken}&user=${encodeURIComponent(JSON.stringify(user))}`;\r\n-    res.redirect(redirectUrl);\r\n-  } catch (error) {\r\n-    logger.error('Facebook OAuth callback error:', error);\r\n-    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n-  }\r\n-};\r\n-\r\n-// @desc    Forgot password\r\n-// @route   POST /api/v1/auth/forgot-password\r\n-// @access  Public\r\n-export const forgotPassword = async (req, res) => {\r\n-  try {\r\n-    const { email } = req.body;\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) {\r\n-      return res.status(404).json({\r\n-        success: false,\r\n-        error: 'User not found with this email',\r\n-      });\r\n-    }\r\n-\r\n-    // Generate reset token\r\n-    const resetToken = crypto.randomBytes(32).toString('hex');\r\n-    user.passwordResetToken = crypto\r\n-      .createHash('sha256')\r\n-      .update(resetToken)\r\n-      .digest('hex');\r\n-    user.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes\r\n-\r\n-    await user.save();\r\n-\r\n-    // TODO: Send email with reset link\r\n-    // For now, just return the token (in production, send via email)\r\n-    res.json({\r\n-      success: true,\r\n-      message: 'Password reset email sent',\r\n-      data: {\r\n-        resetToken: process.env.NODE_ENV === 'development' ? resetToken : undefined,\r\n-      },\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Forgot password error:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: 'Failed to send reset email',\r\n-    });\r\n-  }\r\n-};\r\n-\r\n-// @desc    Reset password\r\n-// @route   POST /api/v1/auth/reset-password\r\n-// @access  Public\r\n-export const resetPassword = async (req, res) => {\r\n-  try {\r\n-    const { token, password } = req.body;\r\n-\r\n-    // Get hashed token\r\n-    const passwordResetToken = crypto\r\n-      .createHash('sha256')\r\n-      .update(token)\r\n-      .digest('hex');\r\n-\r\n-    const user = await User.findOne({\r\n-      passwordResetToken,\r\n-      passwordResetExpires: { $gt: Date.now() },\r\n-    });\r\n-\r\n-    if (!user) {\r\n-      return res.status(400).json({\r\n-        success: false,\r\n-        error: 'Invalid or expired reset token',\r\n-      });\r\n-    }\r\n-\r\n-    // Set new password\r\n-    user.password = password;\r\n-    user.passwordResetToken = undefined;\r\n-    user.passwordResetExpires = undefined;\r\n-    await user.save();\r\n-\r\n-    res.json({\r\n-      success: true,\r\n-      message: 'Password reset successful',\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Reset password error:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: 'Password reset failed',\r\n-    });\r\n-  }\r\n-};\r\n-\r\n-// @desc    Refresh token\r\n-// @route   POST /api/v1/auth/refresh\r\n-// @access  Public\r\n-export const refreshToken = async (req, res) => {\r\n-  try {\r\n-    const { refreshToken } = req.body;\r\n-\r\n-    if (!refreshToken) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        error: 'Refresh token is required',\r\n-      });\r\n-    }\r\n-\r\n-    // Verify refresh token\r\n-    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\r\n-    const user = await User.findById(decoded.id);\r\n-\r\n-    if (!user) {\r\n-      return res.status(401).json({\r\n-        success: false,\r\n-        error: 'Invalid refresh token',\r\n-      });\r\n-    }\r\n-\r\n-    // Generate new tokens\r\n-    const newToken = generateToken(user._id);\r\n-    const newRefreshToken = generateRefreshToken(user._id);\r\n-\r\n-    res.json({\r\n-      success: true,\r\n-      data: {\r\n-        accessToken: newToken,\r\n-        refreshToken: newRefreshToken,\r\n-      },\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Refresh token error:', error);\r\n-    res.status(401).json({\r\n-      success: false,\r\n-      error: 'Invalid refresh token',\r\n-    });\r\n-  }\r\n-};\r\n-\r\n-// @desc    Logout user\r\n-// @route   POST /api/v1/auth/logout\r\n-// @access  Private\r\n-export const logout = async (req, res) => {\r\n-  try {\r\n-    // In a more complex setup, you might want to blacklist the token\r\n-    // For now, we'll just return a success response\r\n-    res.json({\r\n-      success: true,\r\n-      message: 'Logout successful',\r\n-    });\r\n-  } catch (error) {\r\n-    logger.error('Logout error:', error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: 'Logout failed',\r\n-    });\r\n-  }\r\n+  if (!req.user) return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n+  const token = generateToken(req.user._id);\r\n+  res.redirect(`${process.env.FRONTEND_URL}/oauth-callback?token=${token}`);\r\n }; \n\\ No newline at end of file\n"
                },
                {
                    "date": 1753100057761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,10 +38,13 @@\n     const isMatch = await user.comparePassword(password);\r\n     if (!isMatch) {\r\n       return res.status(401).json({ success: false, error: 'Invalid credentials.' });\r\n     }\r\n-    const token = generateToken(user._id);\r\n-    res.json({ success: true, data: { user, accessToken: token } });\r\n+    // This is the key part:\r\n+    req.login(user, (err) => {\r\n+      if (err) return res.status(500).json({ success: false, error: err.message });\r\n+      res.json({ success: true, user });\r\n+    });\r\n   } catch (err) {\r\n     res.status(500).json({ success: false, error: err.message });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1753100215269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,13 +38,10 @@\n     const isMatch = await user.comparePassword(password);\r\n     if (!isMatch) {\r\n       return res.status(401).json({ success: false, error: 'Invalid credentials.' });\r\n     }\r\n-    // This is the key part:\r\n-    req.login(user, (err) => {\r\n-      if (err) return res.status(500).json({ success: false, error: err.message });\r\n-      res.json({ success: true, user });\r\n-    });\r\n+    const token = generateToken(user._id);\r\n+    res.json({ success: true, data: { user, accessToken: token } });\r\n   } catch (err) {\r\n     res.status(500).json({ success: false, error: err.message });\r\n   }\r\n };\r\n"
                }
            ],
            "date": 1752729064162,
            "name": "Commit-0",
            "content": "import User from '../models/User.js';\r\nimport { generateToken, generateRefreshToken } from '../middleware/auth.js';\r\nimport { logger } from '../config/logger.js';\r\nimport crypto from 'crypto';\r\nimport axios from 'axios';\r\n\r\n// @desc    Register user\r\n// @route   POST /api/v1/auth/register\r\n// @access  Public\r\nexport const register = async (req, res) => {\r\n  try {\r\n    const {\r\n      username,\r\n      email,\r\n      password,\r\n      firstName,\r\n      lastName,\r\n      dateOfBirth,\r\n      referredBy,\r\n    } = req.body;\r\n\r\n    // Check if user already exists\r\n    const existingUser = await User.findByEmailOrUsername(email);\r\n    if (existingUser) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'User already exists with this email or username',\r\n      });\r\n    }\r\n\r\n    // Check if username is taken\r\n    const usernameExists = await User.findOne({ username });\r\n    if (usernameExists) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Username is already taken',\r\n      });\r\n    }\r\n\r\n    // Handle referral\r\n    let referredByUser = null;\r\n    if (referredBy) {\r\n      referredByUser = await User.findByReferralCode(referredBy);\r\n      if (!referredByUser) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          error: 'Invalid referral code',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Create user\r\n    const user = new User({\r\n      username,\r\n      email,\r\n      password,\r\n      firstName,\r\n      lastName,\r\n      dateOfBirth: new Date(dateOfBirth),\r\n      referredBy: referredByUser?._id,\r\n      loginMethod: 'local',\r\n    });\r\n\r\n    await user.save();\r\n\r\n    // Update referrer's referral count\r\n    if (referredByUser) {\r\n      referredByUser.referralCount += 1;\r\n      await referredByUser.save();\r\n    }\r\n\r\n    // Generate tokens\r\n    const token = generateToken(user._id);\r\n    const refreshToken = generateRefreshToken(user._id);\r\n\r\n    // Update last login\r\n    user.lastLogin = new Date();\r\n    await user.save();\r\n\r\n    res.status(201).json({\r\n      success: true,\r\n      data: {\r\n        user: {\r\n          id: user._id,\r\n          username: user.username,\r\n          email: user.email,\r\n          firstName: user.firstName,\r\n          lastName: user.lastName,\r\n          isEmailVerified: user.isEmailVerified,\r\n          balance: user.balance,\r\n          level: user.level,\r\n          experience: user.experience,\r\n          referralCode: user.referralCode,\r\n        },\r\n        accessToken: token,\r\n        refreshToken: refreshToken,\r\n      },\r\n      message: 'Registration successful',\r\n    });\r\n  } catch (error) {\r\n    logger.error('Registration error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Registration failed',\r\n    });\r\n  }\r\n};\r\n\r\n// @desc    Login user\r\n// @route   POST /api/v1/auth/login\r\n// @access  Public\r\nexport const login = async (req, res) => {\r\n  try {\r\n    const { username, password, captchaToken } = req.body;\r\n\r\n    // Verify reCAPTCHA\r\n    if (process.env.NODE_ENV === 'production') {\r\n      const recaptchaResponse = await axios.post(\r\n        'https://www.google.com/recaptcha/api/siteverify',\r\n        null,\r\n        {\r\n          params: {\r\n            secret: process.env.RECAPTCHA_SECRET_KEY,\r\n            response: captchaToken,\r\n          },\r\n        }\r\n      );\r\n\r\n      if (!recaptchaResponse.data.success) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          error: 'reCAPTCHA verification failed',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Find user by username or email\r\n    const user = await User.findByEmailOrUsername(username);\r\n    if (!user) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Invalid credentials',\r\n      });\r\n    }\r\n\r\n    // Check if account is locked\r\n    if (user.isLocked()) {\r\n      return res.status(423).json({\r\n        success: false,\r\n        error: 'Account is temporarily locked due to too many failed attempts',\r\n      });\r\n    }\r\n\r\n    // Check if account is banned\r\n    if (user.isBanned) {\r\n      return res.status(403).json({\r\n        success: false,\r\n        error: `Account is banned: ${user.banReason}`,\r\n      });\r\n    }\r\n\r\n    // Check if account is active\r\n    if (!user.isActive) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Account is deactivated',\r\n      });\r\n    }\r\n\r\n    // Verify password\r\n    const isPasswordValid = await user.comparePassword(password);\r\n    if (!isPasswordValid) {\r\n      // Increment login attempts\r\n      await user.incLoginAttempts();\r\n      \r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Invalid credentials',\r\n      });\r\n    }\r\n\r\n    // Reset login attempts on successful login\r\n    if (user.loginAttempts > 0) {\r\n      user.loginAttempts = 0;\r\n      user.lockUntil = undefined;\r\n    }\r\n\r\n    // Update last login\r\n    user.lastLogin = new Date();\r\n    await user.save();\r\n\r\n    // Generate tokens\r\n    const token = generateToken(user._id);\r\n    const refreshToken = generateRefreshToken(user._id);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        user: {\r\n          id: user._id,\r\n          username: user.username,\r\n          email: user.email,\r\n          firstName: user.firstName,\r\n          lastName: user.lastName,\r\n          isEmailVerified: user.isEmailVerified,\r\n          balance: user.balance,\r\n          level: user.level,\r\n          experience: user.experience,\r\n          referralCode: user.referralCode,\r\n          avatar: user.avatar,\r\n        },\r\n        accessToken: token,\r\n        refreshToken: refreshToken,\r\n      },\r\n      message: 'Login successful',\r\n    });\r\n  } catch (error) {\r\n    logger.error('Login error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Login failed',\r\n    });\r\n  }\r\n};\r\n\r\n// @desc    Google OAuth login\r\n// @route   GET /api/v1/auth/google\r\n// @access  Public\r\nexport const googleAuth = (req, res, next) => {\r\n  // This will be handled by passport middleware\r\n  next();\r\n};\r\n\r\n// @desc    Google OAuth callback\r\n// @route   GET /api/v1/auth/google/callback\r\n// @access  Public\r\nexport const googleCallback = (req, res) => {\r\n  try {\r\n    const { user } = req;\r\n    \r\n    if (!user) {\r\n      return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n    }\r\n\r\n    // Generate tokens\r\n    const token = generateToken(user._id);\r\n    const refreshToken = generateRefreshToken(user._id);\r\n\r\n    // Update last login\r\n    user.lastLogin = new Date();\r\n    user.save();\r\n\r\n    // Redirect to frontend with tokens\r\n    const redirectUrl = `${process.env.FRONTEND_URL}/oauth-callback?token=${token}&refreshToken=${refreshToken}&user=${encodeURIComponent(JSON.stringify(user))}`;\r\n    res.redirect(redirectUrl);\r\n  } catch (error) {\r\n    logger.error('Google OAuth callback error:', error);\r\n    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n  }\r\n};\r\n\r\n// @desc    Facebook OAuth login\r\n// @route   GET /api/v1/auth/facebook\r\n// @access  Public\r\nexport const facebookAuth = (req, res, next) => {\r\n  // This will be handled by passport middleware\r\n  next();\r\n};\r\n\r\n// @desc    Facebook OAuth callback\r\n// @route   GET /api/v1/auth/facebook/callback\r\n// @access  Public\r\nexport const facebookCallback = (req, res) => {\r\n  try {\r\n    const { user } = req;\r\n    \r\n    if (!user) {\r\n      return res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n    }\r\n\r\n    // Generate tokens\r\n    const token = generateToken(user._id);\r\n    const refreshToken = generateRefreshToken(user._id);\r\n\r\n    // Update last login\r\n    user.lastLogin = new Date();\r\n    user.save();\r\n\r\n    // Redirect to frontend with tokens\r\n    const redirectUrl = `${process.env.FRONTEND_URL}/oauth-callback?token=${token}&refreshToken=${refreshToken}&user=${encodeURIComponent(JSON.stringify(user))}`;\r\n    res.redirect(redirectUrl);\r\n  } catch (error) {\r\n    logger.error('Facebook OAuth callback error:', error);\r\n    res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);\r\n  }\r\n};\r\n\r\n// @desc    Forgot password\r\n// @route   POST /api/v1/auth/forgot-password\r\n// @access  Public\r\nexport const forgotPassword = async (req, res) => {\r\n  try {\r\n    const { email } = req.body;\r\n\r\n    const user = await User.findOne({ email });\r\n    if (!user) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'User not found with this email',\r\n      });\r\n    }\r\n\r\n    // Generate reset token\r\n    const resetToken = crypto.randomBytes(32).toString('hex');\r\n    user.passwordResetToken = crypto\r\n      .createHash('sha256')\r\n      .update(resetToken)\r\n      .digest('hex');\r\n    user.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes\r\n\r\n    await user.save();\r\n\r\n    // TODO: Send email with reset link\r\n    // For now, just return the token (in production, send via email)\r\n    res.json({\r\n      success: true,\r\n      message: 'Password reset email sent',\r\n      data: {\r\n        resetToken: process.env.NODE_ENV === 'development' ? resetToken : undefined,\r\n      },\r\n    });\r\n  } catch (error) {\r\n    logger.error('Forgot password error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to send reset email',\r\n    });\r\n  }\r\n};\r\n\r\n// @desc    Reset password\r\n// @route   POST /api/v1/auth/reset-password\r\n// @access  Public\r\nexport const resetPassword = async (req, res) => {\r\n  try {\r\n    const { token, password } = req.body;\r\n\r\n    // Get hashed token\r\n    const passwordResetToken = crypto\r\n      .createHash('sha256')\r\n      .update(token)\r\n      .digest('hex');\r\n\r\n    const user = await User.findOne({\r\n      passwordResetToken,\r\n      passwordResetExpires: { $gt: Date.now() },\r\n    });\r\n\r\n    if (!user) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: 'Invalid or expired reset token',\r\n      });\r\n    }\r\n\r\n    // Set new password\r\n    user.password = password;\r\n    user.passwordResetToken = undefined;\r\n    user.passwordResetExpires = undefined;\r\n    await user.save();\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Password reset successful',\r\n    });\r\n  } catch (error) {\r\n    logger.error('Reset password error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Password reset failed',\r\n    });\r\n  }\r\n};\r\n\r\n// @desc    Refresh token\r\n// @route   POST /api/v1/auth/refresh\r\n// @access  Public\r\nexport const refreshToken = async (req, res) => {\r\n  try {\r\n    const { refreshToken } = req.body;\r\n\r\n    if (!refreshToken) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Refresh token is required',\r\n      });\r\n    }\r\n\r\n    // Verify refresh token\r\n    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\r\n    const user = await User.findById(decoded.id);\r\n\r\n    if (!user) {\r\n      return res.status(401).json({\r\n        success: false,\r\n        error: 'Invalid refresh token',\r\n      });\r\n    }\r\n\r\n    // Generate new tokens\r\n    const newToken = generateToken(user._id);\r\n    const newRefreshToken = generateRefreshToken(user._id);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        accessToken: newToken,\r\n        refreshToken: newRefreshToken,\r\n      },\r\n    });\r\n  } catch (error) {\r\n    logger.error('Refresh token error:', error);\r\n    res.status(401).json({\r\n      success: false,\r\n      error: 'Invalid refresh token',\r\n    });\r\n  }\r\n};\r\n\r\n// @desc    Logout user\r\n// @route   POST /api/v1/auth/logout\r\n// @access  Private\r\nexport const logout = async (req, res) => {\r\n  try {\r\n    // In a more complex setup, you might want to blacklist the token\r\n    // For now, we'll just return a success response\r\n    res.json({\r\n      success: true,\r\n      message: 'Logout successful',\r\n    });\r\n  } catch (error) {\r\n    logger.error('Logout error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Logout failed',\r\n    });\r\n  }\r\n}; "
        }
    ]
}